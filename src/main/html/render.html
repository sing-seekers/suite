<meta charset='utf-8'>
<!--
file:///home/ywsing/suite/src/main/html/render.html
-->
<!DOCTYPE html>
<html>
	<body>
		<style>
			.overlay {
				background-color: white;
				bottom: 0;
				left: 0;
				position: fixed;
				right: 0;
				top: 0;
				opacity: 0.8;
				z-index: 9998;
			}
		</style>
		<div id='target'></div>
	</body>

	<script src='eval-script.js'></script>
	<script src='frp.js'></script>

	<script type='text/javascript'>
'use strict';

Promise.resolve({})
.then(ns => evalscript('fun.js').then(m => ({ ...ns, fun: m, })))
.then(ns => evalscript('render.js').then(m => ({ ...ns, render: m, })))
.then(ns => {
	let { fun: { lens, read, }, render: { rd, renderAgain, }, } = ns;

	let fetchBase = { cache: 'no-cache', credentials: 'omit', redirect: 'follow', referrer: 'no-referrer', };

	let view;

	let login = ({ username, password, }) => {
		console.log('login()', username);

		return Promise
		.resolve()
		.then(() => renderAgain(view, vm => ({ ...vm, overlay: { isOverlay: true, }, })))
		.then(() => fetch('../token', {
			...fetchBase,
			mode: 'no-cors',
			body: JSON.stringify({ username, password, }),
			headers: { 'Content-Type': 'application/json', },
			method: 'POST',
		}))
		.then(response => {
			if (response.ok) return response.json(); else throw response.statusText;
		})
		.then(json => json.token)
		.then(token => fetch('../token', {
			...fetchBase,
			headers: { 'Authorization': token, },
			method: 'PATCH',
		}))
		.then(response => {
			if (response.ok) return response.json(); else throw response.statusText;
		})
		.then(json => json.token)
		.then(token => { renderAgain(view, vm => ({ ...vm, token, })); return token; })
		.then(token => fetch('../api', {
			...fetchBase,
			headers: { 'Authorization': token, },
			method: 'GET',
		}))
		.then(response => {
			if (response.ok) return response.text(); else throw response.statusText;
		})
		.then(message => {
			renderAgain(view, vm => ({ ...vm, message, }));
			console.log('login() = ', message);
		})
		.catch(error => {
			console.error('login()', error);
			renderAgain(view, vm => ({ ...vm, token: error, }));
		})
		.finally(() => renderAgain(view, vm => ({ ...vm, overlay: { isOverlay: false, }, })));
	};

	let component = (path, initvm, xhtml, envf) => {
		let lens_ = lens.key(path);
		let change = f => renderAgain(view, vm => ({ ...vm, [path]: f(vm[path]), }));
		return {
			init: () => renderAgain(view, vm => ({ ...vm, [path]: initvm, })),
			view: rd.parse(`<rd_map v='vm.${path}'>${xhtml}</rd_map>`, envf(change)),
		};
	};

	let componentLogin = component(
		'login',
		{ username: '', password: '', },
		`
			<font face='Monospac821 BT, Monaco, Consolas'>
				<form name='login'>
					Username <input rd_on_input='env.setUsername(ev.target.value)' value='{ vm.username }' type='text' autofocus='autofocus' /><br />
					Password <input rd_on_input='env.setPassword(ev.target.value)' value='{ vm.password }' type='password' /><br />
					<input type='button' value='Login' rd_on_click='env.handleLogin()' /><br />
					token: { vm.token }
				</form>
			</font>
		`,
		change => ({
			setUsername: username => change(vm => ({ ...vm, username, })),
			setPassword: password => change(vm => ({ ...vm, password, })),
			handleLogin: () => change(vm => {
				login(vm);
				return { username: '', password: '', };
			}),
		}),
	);

	let componentOverlay = component(
		'overlay',
		{ isOverlay: false, },
		`<div class='{ vm.isOverlay ? "overlay" : "" }'></div>`,
		change => ({}),
	);

	let view0 = rd.parse(`
		<span style='font-family: sans-serif;'>
			<rd_component v='env.viewLogin' />
			<rd_component v='env.viewOverlay' />

			<rd_map v='vm.message'>
				<p style='font-weight: bold;'>
					{ vm } within scope
					<!-- comment -->
				</p>
			</rd_map>
			<rd_map v='vm.t'>
				{ vm }
			</rd_map>
			<ul>
				<rd_for v='vm.fruits'><li>{ vm }</li></rd_for>
			</ul>
			<div>
				<!--rd_map v='vm.sse'>server sent events: <rd_for>{ vm }</rd_for></rd_map-->
			</div>
			<div style='
				background-color: rgb(0, 0, 0);
				background-color: rgb(0, 0, 0, 0.4);
				display: { vm.isPopup ? "block" : "none" };
				height: 100%;
				left: 0;
				overflow: auto;
				position: fixed;
				top: 0;
				width: 100%;
				z-index: 1;'>
				<div style='
					background-color: #FEFEFE;
					border: 1px solid #888;
					margin: 15% auto;
					padding: 20px;
					width: 50%;'>
					<span rd_on_click='messager(false)'
						style='
						cursor: pointer;
						font-size: 28px;
						float: right;'>
						Ã—
					</span>
					<p>Climb every mountain</p>
					<p>Another</p>
				</div>
			</div>
			<button rd_on_click='messager(true)'>Message</button>
			<button rd_on_click='closer()'>Close</button>
		</span>
	`, {
		viewLogin: componentLogin.view,
		viewOverlay: componentOverlay.view,
	});

	let view1 = rd.span().children(
		rd.map(vm => vm.message,
			rd.p().style({ 'font-weight': 'bold', }).text().rd()
		),
		rd.map(vm => vm.t,
			rd.p().text().rd()
		),
		rd.map(vm => vm.fruits,
			rd.ul().child(rd.for(vm => vm, rd.li().text().rd())).rd()
		),
		rd.tag('button').child(rd.dom(vm => document.createTextNode('Close'))).listen('click', ev => close()).rd(),
	).rd();

	view = rd
		.span()
		.style({ 'font-family': 'sans-serif', })
		.child(
			rd.list([
				view0,
				view1,
				rd.p().rd(),
				rd.map(vm => vm.vscroll, rd
					.vscrollf(200, 32,
						rd.dom(vm => document.createTextNode('item ' + vm)),
						start1 => renderAgain(view, lens.key('vscroll').key('start').apply(start0 => start1)),
					)
					.style({ width: '400px', })
					.rd()
				),
			]),
		)
		.rd();

	let sse = [];
	let t = 0;
	let vscroll = { start: 0, vms: read().range(0, 256).list(), };

	let upd0 = lens.key('t').apply(t => t + 1);
	let upd1 = lens.key('vscroll').key('vms').index(3).apply(vm => Math.random().toString());

	let interval0 = setInterval(() => renderAgain(view, upd0), 1000);
	let interval1 = setInterval(() => renderAgain(view, upd1), 3000);

	componentLogin.init();
	componentOverlay.init();
	renderAgain(view, vm => ({ ...vm, sse, t, vscroll, message: 'hello world0', fruits: ['banana',], }));
	renderAgain(view, vm => ({ ...vm, sse, t, vscroll, message: 'hello world1', fruits: ['apple', 'banana',], }));
	renderAgain(view, vm => ({ ...vm, sse, t, vscroll, message: 'hello world2', fruits: ['apple', 'orange', 'orange', 'banana',], }));
	renderAgain(view, vm => ({ ...vm, sse, t, vscroll, message: 'hello world~', fruits: ['banana', 'orange',], }));

	globalThis.closer = () => {
		clearInterval(interval0);
		clearInterval(interval1);
		renderAgain(view, vm => null);
	};

	globalThis.messager = b => renderAgain(view, vm => ({ ...vm, isPopup: b }));

	let eventSource = new EventSource('/sse');

	eventSource.onError = error => console.log(error);
	eventSource.onMessage = event => console.log(event);

	eventSource.addEventListener("close", ev => eventSource.close());
	eventSource.addEventListener("number", ev => renderAgain(view, vm => ({ ...vm, sse: [...vm.sse, JSON.parse(ev.data).i,], })));
});

	</script>
</html>

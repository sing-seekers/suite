<meta charset='utf-8'>
<!--
file:///home/ywsing/suite/src/main/html/render.html
-->
<!DOCTYPE html>
<html>
	<body>
		<div id='target'></div>
	</body>

	<script src='frp.js'></script>
	<script src='fun.js'></script>
	<script src='render.js'></script>

	<script type='text/javascript'>
let login = () => {
	console.log('logging in');
	let username = document.getElementById('username').value;
	let password = document.getElementById('password').value;

	let formData = new FormData();
	formData.append('username', username);
	formData.append('password', password);
	// formData.append('photo', document.querySelector('input[type="file"][multiple]').files[0]);

	fetch('/token', {
		// body: formData,
		body: JSON.stringify({ username, password, }),
		cache: 'no-cache',
		credentials: 'omit',
		headers: { 'Content-Type': 'application/json', },
		// headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
		method: 'POST',
		mode: 'no-cors',
		redirect: 'follow',
		referrer: 'no-referrer',
	})
	.then(response => response.json())
	.then(json => json.token)
	.then(token => fetch('/token', {
		headers: { 'Authorization': token, },
		method: 'PATCH',
	}))
	.then(response => response.json())
	.then(json => json.token)
	.then(token => { renderAgain(view, vm => ({ ...vm, token, })); return token; })
	.then(token => fetch('/api', {
		headers: { 'Authorization': token, },
		method: 'GET',
	}))
	.then(response => response.text())
	.then(text => console.log(text))
	.catch(error => {
		console.error("login", error);
		renderAgain(view, vm => ({ ...vm, token: 'login failed', }));
	});
};

let { lens, range, read, } = fun();
let { rd, renderAgain, } = render();
let close;

let view0 = rd.parse(`
	<span style='font-family: sans-serif;'>
		<font face='Monospac821 BT, Monaco, Consolas'>
			<form name='login'>
				Username <input id='username' type='text' autofocus='autofocus' /><br />
				Password <input id='password' type='password' /><br />
				<input type='button' value='Login' rd_on_click='login()' /><br />
				token: { vm.token }
			</form>
		</font>

		<rd_map v='vm.message'>
			<p style='font-weight: bold;'>
				{ vm } within scope
				<!-- comment -->
			</p>
		</rd_map>
		<rd_map v='vm.t'>
			{ vm }
		</rd_map>
		<ul>
			<rd_for v='vm.fruits'><li>{ vm }</li></rd_for>
		</ul>
		<div>
			<!--rd_map v='vm.sse'>server sent events: <rd_for>{ vm }</rd_for></rd_map-->
		</div>
		<button rd_on_click='close()'>Close</button>
	</span>
`);

let view1 = rd.span().children(
	rd.map(vm => vm.message,
		rd.p().style({ 'font-weight': 'bold', }).text().rd()
	),
	rd.map(vm => vm.t,
		rd.p().text().rd()
	),
	rd.map(vm => vm.fruits,
		rd.ul().child(rd.for(vm => vm, rd.li().text().rd())).rd()
	),
	rd.tag('button').child(rd.dom(vm => document.createTextNode('Close'))).listen('click', (vm, ev) => close()).rd(),
).rd();

let view = rd
	.span()
	.style({ 'font-family': 'sans-serif', })
	.child(
		rd.list([
			view0,
			view1,
			rd.p().rd(),
			rd.map(vm => vm.vscroll, rd
				.vscrollf(200, 32,
					rd.dom(vm => document.createTextNode('item ' + vm)),
					start1 => renderAgain(view, lens.key('vscroll').key('start').apply(start0 => start1)),
				)
				.style({ width: '400px', })
				.rd()
			),
		]),
	)
	.rd();

let sse = [];
let t = 0;
let vscroll = { start: 0, vms: read().range(0, 256).list(), };

let upd0 = lens.key('t').apply(t => t + 1);
let upd1 = lens.key('vscroll').key('vms').index(3).apply(vm => Math.random().toString());

let interval0 = setInterval(() => renderAgain(view, upd0), 1000);
let interval1 = setInterval(() => renderAgain(view, upd1), 3000);

renderAgain(view, vm => ({ sse, t, vscroll, message: 'hello world0', fruits: ['banana',], }));
renderAgain(view, vm => ({ sse, t, vscroll, message: 'hello world1', fruits: ['apple', 'banana',], }));
renderAgain(view, vm => ({ sse, t, vscroll, message: 'hello world2', fruits: ['apple', 'orange', 'orange', 'banana',], }));
renderAgain(view, vm => ({ sse, t, vscroll, message: 'hello world~', fruits: ['banana', 'orange',], }));

close = () => {
	clearInterval(interval0);
	clearInterval(interval1);
	renderAgain(view, vm => null);
};

let eventSource = new EventSource('/sse');

eventSource.onError = error => console.log(error);
eventSource.onMessage = event => console.log(event);

eventSource.addEventListener("close", ev => eventSource.close());
eventSource.addEventListener("number", ev => renderAgain(view, vm => ({ ...vm, sse: [...vm.sse, JSON.parse(ev.data).i,], })));
	</script>
</html>
